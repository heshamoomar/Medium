module.exports = [
"[project]/node_modules/@kinde/jwt-decoder/dist/jwt-decoder.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TokenPart",
    ()=>s,
    "jwtDecoder",
    ()=>c
]);
var s = /* @__PURE__ */ ((e)=>(e[e.header = 0] = "header", e[e.body = 1] = "body", e))(s || {});
function c(e, t) {
    if (!e) return null;
    const r = e.split(".");
    if (r.length !== 3) return null;
    const n = r[t ?? 1].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(atob(n).split("").map((l)=>"%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(o);
}
;
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$",
    ()=>Q,
    "A",
    ()=>he,
    "B",
    ()=>se,
    "C",
    ()=>ze,
    "D",
    ()=>ie,
    "E",
    ()=>qe,
    "F",
    ()=>Fe,
    "G",
    ()=>x,
    "H",
    ()=>Le,
    "I",
    ()=>_,
    "J",
    ()=>Ne,
    "K",
    ()=>De,
    "L",
    ()=>Ve,
    "M",
    ()=>C,
    "N",
    ()=>Me,
    "O",
    ()=>je,
    "P",
    ()=>Ie,
    "Q",
    ()=>ae,
    "R",
    ()=>le,
    "S",
    ()=>F,
    "T",
    ()=>de,
    "U",
    ()=>me,
    "V",
    ()=>Ce,
    "W",
    ()=>Te,
    "X",
    ()=>Ae,
    "Y",
    ()=>Z,
    "Z",
    ()=>j,
    "_",
    ()=>B,
    "a",
    ()=>i,
    "a0",
    ()=>I,
    "a1",
    ()=>w,
    "b",
    ()=>c,
    "c",
    ()=>V,
    "d",
    ()=>b,
    "e",
    ()=>Se,
    "f",
    ()=>ve,
    "g",
    ()=>E,
    "h",
    ()=>$e,
    "i",
    ()=>xe,
    "j",
    ()=>$,
    "k",
    ()=>q,
    "l",
    ()=>R,
    "m",
    ()=>O,
    "n",
    ()=>y,
    "o",
    ()=>Be,
    "p",
    ()=>_e,
    "q",
    ()=>te,
    "r",
    ()=>L,
    "s",
    ()=>z,
    "t",
    ()=>G,
    "u",
    ()=>Ee,
    "v",
    ()=>Pe,
    "w",
    ()=>m,
    "x",
    ()=>Ue,
    "y",
    ()=>be,
    "z",
    ()=>Re
]);
var Z = /* @__PURE__ */ ((e)=>(e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(Z || {}), j = /* @__PURE__ */ ((e)=>(e.none = "none", e.create = "create", e.login = "login", e))(j || {}), B = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.paymentDetails = "payment_details", e.planSelection = "plan_selection", e.planDetails = "plan_details", e.profile = "profile", e))(B || {}), Q = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(Q || {}), I = /* @__PURE__ */ ((e)=>(e.logout = "logout", e.login = "login", e.register = "registration", e.token = "token", e.profile = "profile", e))(I || {}), w = /* @__PURE__ */ ((e)=>(e[e.refreshToken = 0] = "refreshToken", e[e.cookie = 1] = "cookie", e))(w || {});
const V = (e)=>{
    const t = (a)=>btoa(a).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    if (e instanceof ArrayBuffer) {
        const a = new Uint8Array(e), o = String.fromCharCode(...a);
        return t(o);
    }
    const s = new TextEncoder().encode(e), n = String.fromCharCode(...s);
    return t(n);
}, E = (e = 28)=>{
    if (crypto) {
        const t = new Uint8Array(e / 2);
        return crypto.getRandomValues(t), Array.from(t, X).join("");
    } else return Y(e);
};
function X(e) {
    return e.toString(16).padStart(2, "0");
}
function Y(e = 28) {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let r = "";
    const s = t.length;
    for(let n = 0; n < e; n++)r += t.charAt(Math.floor(Math.random() * s));
    return r;
}
const Se = (e)=>{
    e = e.split("?")[1];
    const t = new URLSearchParams(e);
    return {
        accessToken: t.get("access_token"),
        idToken: t.get("id_token"),
        expiresIn: +(t.get("expires_in") || 0)
    };
}, b = (e)=>e.replace(/\/$/, ""), O = (e, t = !1)=>{
    const r = Array.isArray(e.audience) ? e.audience.join(" ") : e.audience || "", s = {
        login_hint: e.loginHint,
        is_create_org: e.isCreateOrg?.toString(),
        connection_id: e.connectionId,
        redirect_uri: e.redirectURL ? t ? e.redirectURL : b(e.redirectURL) : void 0,
        audience: r,
        scope: e.scope?.join(" ") || "email profile openid offline",
        prompt: e.prompt,
        lang: e.lang,
        org_code: e.orgCode,
        org_name: e.orgName,
        has_success_page: e.hasSuccessPage?.toString(),
        workflow_deployment_id: e.workflowDeploymentId,
        supports_reauth: e.supportsReauth?.toString(),
        plan_interest: e.planInterest,
        pricing_table_key: e.pricingTableKey,
        pages_mode: e.pagesMode
    };
    return Object.keys(s).forEach((n)=>s[n] === void 0 && delete s[n]), s;
}, P = (e)=>typeof e != "object" || e === null ? e : Array.isArray(e) ? e.map((t)=>P(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
            t.replace(/_([a-z])/g, (s, n)=>n.toUpperCase()),
            P(r)
        ])), K = [
    // UTM tags
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_content",
    "utm_term",
    // Google Ads smart campaign tracking
    "gclid",
    "click_id",
    "hsa_acc",
    "hsa_cam",
    "hsa_grp",
    "hsa_ad",
    "hsa_src",
    "hsa_tgt",
    "hsa_kw",
    "hsa_mt",
    "hsa_net",
    "hsa_ver",
    // Marketing category
    "match_type",
    "keyword",
    "device",
    "ad_group_id",
    "campaign_id",
    "creative",
    "network",
    "ad_position",
    "fbclid",
    "li_fat_id",
    "msclkid",
    "twclid",
    "ttclid"
], ve = async (e, t = I.login, r, s)=>{
    const n = `${e}/oauth2/auth`, a = C();
    if (r.reauthState) try {
        const f = P(JSON.parse(atob(r.reauthState)));
        r = {
            ...r,
            ...f
        }, delete r.reauthState;
    } catch (f) {
        const h = f instanceof Error ? f.message : "Unknown error";
        throw new Error(`Error handing reauth state: ${h}`);
    }
    if (!r.clientId) throw new Error("Error generating auth URL: Client ID missing");
    const o = {
        client_id: r.clientId,
        response_type: r.responseType || "code",
        ...O(r, s?.disableUrlSanitization)
    };
    r.state || (r.state = E(32)), a && a.setSessionItem(i.state, r.state), o.state = r.state, r.nonce || (r.nonce = E(16)), o.nonce = r.nonce, a && a.setSessionItem(i.nonce, r.nonce);
    let u = "";
    if (r.codeChallenge) o.code_challenge = r.codeChallenge;
    else {
        const { codeVerifier: f, codeChallenge: h } = await ee();
        u = f, a && a.setSessionItem(i.codeVerifier, f), o.code_challenge = h;
    }
    o.code_challenge_method = "S256", r.codeChallengeMethod && (o.code_challenge_method = r.codeChallengeMethod), !r.prompt && t === I.register && (o.prompt = j.create), r.properties && Object.keys(r.properties).forEach((f)=>{
        if (!K.includes(f)) {
            console.warn("Unsupported Property for url generation: ", f);
            return;
        }
        const h = r.properties?.[f];
        h !== void 0 && (o[f] = h);
    });
    const l = new URLSearchParams(o).toString();
    return {
        url: new URL(`${n}?${l}`),
        state: o.state,
        nonce: o.nonce,
        codeChallenge: o.code_challenge,
        codeVerifier: u
    };
};
async function ee() {
    const e = E(52), t = new TextEncoder().encode(e);
    let r = "";
    if (!crypto) r = V(btoa(e));
    else {
        const s = await crypto.subtle.digest("SHA-256", t);
        r = V(s);
    }
    return {
        codeVerifier: e,
        codeChallenge: r
    };
}
let v;
function q(e, t) {
    if (R(), "undefined" > "u") throw new Error("setRefreshTimer requires a browser environment");
    if (e <= 0) throw new Error("Timer duration must be positive");
    v = window.setTimeout(t, Math.min(e * 1e3 - 1e4, 864e5));
}
function R() {
    v !== void 0 && (window.clearTimeout(v), v = void 0);
}
const y = {
    framework: "",
    frameworkVersion: "",
    sdkVersion: ""
}, M = async ()=>{
    await C()?.removeItems(i.state, i.nonce, i.codeVerifier);
}, te = ()=>`${y.framework}/${y.sdkVersion}/${y.frameworkVersion}/Javascript`, $e = async ({ urlParams: e, domain: t, clientId: r, redirectURL: s, autoRefresh: n = !1, onRefresh: a })=>{
    const o = e.get("state"), u = e.get("code");
    if (!o || !u) return console.error("Invalid state or code"), {
        success: !1,
        error: "Invalid state or code"
    };
    const l = C();
    if (!l) return console.error("No active storage found"), {
        success: !1,
        error: "Authentication storage is not initialized"
    };
    (!y.framework || !y.frameworkVersion) && console.warn("Framework and version not set. Please set the framework and version in the config object");
    const f = await l.getSessionItem(i.state);
    if (o !== f) return console.error("Invalid state"), {
        success: !1,
        error: `Invalid state; supplied ${o}, expected ${f}`
    };
    const h = await l.getSessionItem(i.codeVerifier);
    if (h === null) return console.error("Code verifier not found"), {
        success: !1,
        error: "Code verifier not found"
    };
    const N = {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
    };
    y.framework && (N["Kinde-SDK"] = te());
    const J = {
        method: "POST",
        ...!c.useInsecureForRefreshToken && $(t) ? {
            credentials: "include"
        } : {},
        headers: new Headers(N),
        body: new URLSearchParams({
            client_id: r,
            code: u,
            code_verifier: h,
            grant_type: "authorization_code",
            redirect_uri: s
        })
    };
    let p;
    R();
    try {
        if (p = await fetch(`${t}/oauth2/token`, J), !p?.ok) {
            const k = await p.text();
            return console.error("Token exchange failed:", p.status, k), {
                success: !1,
                error: `Token exchange failed: ${p.status} - ${k}`
            };
        }
    } catch (k) {
        return M(), console.error("Token exchange failed:", k), {
            success: !1,
            error: `Token exchange failed: ${k}`
        };
    }
    const d = await p.json(), D = _();
    D && D.setItems({
        [i.accessToken]: d.access_token,
        [i.idToken]: d.id_token,
        [i.refreshToken]: d.refresh_token
    }), (c.useInsecureForRefreshToken || !$(t)) && l.setSessionItem(i.refreshToken, d.refresh_token), n && q(d.expires_in, async ()=>{
        x({
            domain: t,
            clientId: r,
            onRefresh: a
        });
    }), M();
    const W = ((k)=>(k.search = "", k))(new URL(window.location.toString()));
    return window.history.replaceState(window.history.state, "", W), !d.access_token || !d.id_token || !d.refresh_token ? {
        success: !1,
        error: "No access token received"
    } : {
        success: !0,
        [i.accessToken]: d.access_token,
        [i.idToken]: d.id_token,
        [i.refreshToken]: d.refresh_token
    };
};
function re(e) {
    const r = document.cookie.split("; ").find((s)=>s.startsWith(`${e}=`));
    if (!r) return null;
    try {
        const s = r.split("=")[1];
        return s ? decodeURIComponent(s) : null;
    } catch (s) {
        return console.error(`Error parsing cookie ${e}:`, s), null;
    }
}
const ne = "_kbrte", xe = async ({ domain: e, clientId: t })=>{
    if (!e) return {
        success: !1,
        error: "Domain is required for authentication check"
    };
    if (!t) return {
        success: !1,
        error: "Client ID is required for authentication check"
    };
    const r = $(e), s = c.useInsecureForRefreshToken;
    let n = null;
    return r && !s && (n = re(ne)), await x({
        domain: e,
        clientId: t,
        refreshType: n ? w.cookie : w.refreshToken
    });
}, $ = (e)=>!e.match(/^(?:https?:\/\/)?[a-zA-Z0-9][.-a-zA-Z0-9]*\.kinde\.com$/i);
function z(e, t) {
    return t <= 0 ? [] : e.match(new RegExp(`.{1,${t}}`, "g")) || [];
}
var i = /* @__PURE__ */ ((e)=>(e.accessToken = "accessToken", e.idToken = "idToken", e.refreshToken = "refreshToken", e.state = "state", e.nonce = "nonce", e.codeVerifier = "codeVerifier", e))(i || {});
class F {
    async setItems(t) {
        await Promise.all(Object.entries(t).map(([r, s])=>this.setSessionItem(r, s)));
    }
    async removeItems(...t) {
        await Promise.all(t.map((r)=>this.removeSessionItem(r)));
    }
}
class Ce extends F {
    memCache = {};
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.memCache = {};
    }
    /**
   * Sets the provided key-value store to the memory cache.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), typeof r == "string") {
            z(r, c.maxLength).forEach((s, n)=>{
                this.memCache[`${c.keyPrefix}${t}${n}`] = s;
            });
            return;
        }
        this.memCache[`${c.keyPrefix}${String(t)}0`] = r;
    }
    /**
   * Gets the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        if (this.memCache[`${c.keyPrefix}${String(t)}0`] === void 0) return null;
        let r = "", s = 0, n = `${c.keyPrefix}${String(t)}${s}`;
        for(; this.memCache[n] !== void 0;)r += this.memCache[n], s++, n = `${c.keyPrefix}${String(t)}${s}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        for(const r in this.memCache)r.startsWith(`${c.keyPrefix}${String(t)}`) && delete this.memCache[r];
    }
}
function T(e) {
    return new Promise((t, r)=>{
        chrome.storage.local.get([
            e
        ], function(s) {
            chrome.runtime.lastError ? r(void 0) : t(s[e]);
        });
    });
}
class Te extends F {
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        await chrome.storage.local.clear();
    }
    /**
   * Sets the provided key-value store to the chrome.store.local.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), typeof r == "string") {
            z(r, c.maxLength).forEach(async (s, n)=>{
                await chrome.storage.local.set({
                    [`${c.keyPrefix}${t}${n}`]: s
                });
            });
            return;
        }
        await chrome.storage.local.set({
            [`${c.keyPrefix}${t}0`]: r
        });
    }
    /**
   * Gets the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        let r = "", s = 0, n = `${c.keyPrefix}${String(t)}${s}`;
        for(; await T(`${c.keyPrefix}${String(t)}${s}`) !== void 0;)r += await T(n), s++, n = `${c.keyPrefix}${String(t)}${s}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        let r = 0;
        for(; await T(`${c.keyPrefix}${String(t)}${r}`) !== void 0;)await chrome.storage.local.remove(`${c.keyPrefix}${String(t)}${r}`), r++;
    }
}
class Ae extends F {
    constructor(){
        super(), c.useInsecureForRefreshToken && console.warn("LocalStorage store should not be used in production");
    }
    internalItems = /* @__PURE__ */ new Set();
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.internalItems.forEach((t)=>{
            this.removeSessionItem(t);
        });
    }
    /**
   * Sets the provided key-value store to the localStorage cache.
   * @param {V} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), this.internalItems.add(t), typeof r == "string") {
            z(r, c.maxLength).forEach((s, n)=>{
                localStorage.setItem(`${c.keyPrefix}${t}${n}`, s);
            });
            return;
        }
        localStorage.setItem(`${c.keyPrefix}${t}0`, r);
    }
    /**
   * Gets the item for the provided key from the localStorage cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        if (localStorage.getItem(`${c.keyPrefix}${t}0`) === null) return null;
        let r = "", s = 0, n = `${c.keyPrefix}${String(t)}${s}`;
        for(; localStorage.getItem(n) !== null;)r += localStorage.getItem(n), s++, n = `${c.keyPrefix}${String(t)}${s}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the localStorage cache.
   * @param {V} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        let r = 0;
        for(; localStorage.getItem(`${c.keyPrefix}${String(t)}${r}`) !== null;)localStorage.removeItem(`${c.keyPrefix}${String(t)}${r}`), r++;
        this.internalItems.delete(t);
    }
}
const c = {
    /**
   * The prefix to use for the storage keys.
   */ keyPrefix: "kinde-",
    /**
   * The maximum length of the storage.
   *
   * If the length is exceeded the items will be split into multiple storage items.
   */ maxLength: 2e3,
    /**
   * Use insecure storage for refresh token.
   *
   * Warning: This should only be used when you're not using a custom domain and no backend app to authenticate on.
   */ useInsecureForRefreshToken: !1
}, H = (e, t)=>{
    if (Array.isArray(e) && Array.isArray(t)) return Array.from(/* @__PURE__ */ new Set([
        ...e,
        ...t
    ]));
    if (e && typeof e == "object" && t && typeof t == "object") {
        const r = {
            ...e
        };
        for (const s of Object.keys(t))s in r ? r[s] = H(r[s], t[s]) : r[s] = t[s];
        return r;
    }
    return t;
};
async function U(e) {
    const t = _();
    if (!t) throw new Error("No active storage found.");
    const r = await t.getSessionItem(i.accessToken);
    if (!r) throw new Error("Authentication token not found.");
    const s = await L("iss");
    if (!s?.value) throw new Error("Domain (iss claim) not found.");
    let n;
    try {
        n = await fetch(`${s.value}/${e}`, {
            method: "GET",
            headers: {
                Authorization: `Bearer ${r}`,
                "Content-Type": "application/json"
            }
        });
    } catch (o) {
        throw new Error(`Failed to fetch from ${s.value}/${e}: ${o}`);
    }
    if (!n.ok) throw new Error(`API request failed with status ${n.status}`);
    return await n.json();
}
const S = async ({ url: e })=>{
    let t = [], r = await U(e);
    if (t = r.data, r.metadata?.has_more) {
        let s = r.metadata.next_page_starting_after;
        for(; r.metadata.has_more;)r = await U(`${e}?starting_after=${s}`), t = H(t, r.data), s = r.metadata.next_page_starting_after;
    }
    return t;
}, se = async (e)=>{
    if (e?.forceApi) {
        const n = await S({
            url: "account_api/v1/permissions"
        });
        return {
            orgCode: n.org_code,
            permissions: n.permissions?.map((a)=>a.key) || []
        };
    }
    const t = await m();
    if (!t) return {
        orgCode: null,
        permissions: []
    };
    const r = t.permissions || t["x-hasura-permissions"] || [];
    return {
        orgCode: t.org_code || t["x-hasura-org-code"],
        permissions: r
    };
}, oe = (e)=>typeof e == "object" && e !== null && "permission" in e && "condition" in e, ae = async (e)=>{
    if (!e || !e.permissions || e?.permissions?.length === 0) return !0;
    const { permissions: t } = e;
    let r;
    try {
        r = await se({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasPermissions] Error getting permissions", n), !1;
    }
    return (await Promise.all(t.map(async (n)=>oe(n) ? r.permissions.find((o)=>o === n.permission) ? await n.condition({
            permissionKey: n.permission,
            orgCode: r.orgCode
        }) : !1 : !!r.permissions.find((o)=>o === n)))).every((n)=>n === !0);
}, ie = async (e)=>{
    const t = await L("roles");
    if (e?.forceApi || !t?.value) return (await S({
        url: "account_api/v1/roles"
    })).roles?.map((n)=>({
            id: n.id,
            name: n.name,
            key: n.key
        })) || [];
    const r = await m();
    return r ? !r.roles && !r["x-hasura-roles"] ? (console.warn("No roles found in token, ensure roles have been included in the token customisation within the application settings"), []) : r.roles || r["x-hasura-roles"] : [];
}, ce = (e)=>typeof e == "object" && e !== null && "role" in e && "condition" in e, le = async (e)=>{
    if (!e || !e.roles || e?.roles?.length === 0) return !0;
    const { roles: t } = e;
    let r;
    try {
        r = await ie({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasRoles] Error getting roles", n), !1;
    }
    return (await Promise.all(t.map(async (n)=>{
        if (ce(n)) {
            const a = r.find((u)=>u.key === n.role);
            return a ? await n.condition(a) : !1;
        } else return r.map((o)=>o.key).includes(n);
    }))).every((n)=>n === !0);
}, ue = async (e)=>{
    if (e?.forceApi) return (await S({
        url: "account_api/v1/feature_flags"
    })).feature_flags?.map((n)=>({
            key: n.key,
            value: n.value,
            type: n.type
        })) || [];
    const t = await m();
    if (!t) return null;
    const r = t.feature_flags || t["x-hasura-feature-flags"];
    return r ? Object.entries(r).map(([s, n])=>({
            key: s,
            value: n.v,
            type: n.t
        })) : null;
}, fe = (e)=>typeof e == "object" && e !== null && "flag" in e && "value" in e, de = async (e)=>{
    if (!e || !e.featureFlags || e?.featureFlags?.length === 0) return !0;
    const { featureFlags: t } = e;
    let r;
    try {
        r = await ue({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasFeatureFlags] Error getting feature flags", n), !1;
    }
    return t.map((n)=>{
        if (fe(n)) {
            const a = r?.find((o)=>o.key === n.flag);
            return a !== void 0 && a.value === n.value;
        } else return r?.find((o)=>o.key === n) !== void 0;
    }).every((n)=>n === !0);
}, he = async ()=>{
    const e = await S({
        url: "account_api/v1/entitlements"
    });
    return {
        orgCode: e.org_code,
        plans: e.plans?.map((t)=>({
                key: t.key,
                subscribedOn: t.subscribed_on
            })) || [],
        entitlements: e.entitlements?.map((t)=>({
                id: t.id,
                fixedCharge: t.fixed_charge,
                priceName: t.price_name,
                unitAmount: t.unit_amount,
                featureKey: t.feature_key,
                featureName: t.feature_name,
                entitlementLimitMax: t.entitlement_limit_max,
                entitlementLimitMin: t.entitlement_limit_min
            })) || []
    };
}, ge = (e)=>typeof e == "object" && e !== null && "entitlement" in e && "condition" in e, me = async (e)=>{
    if (!e || !e.billingEntitlements || e?.billingEntitlements?.length === 0) return !0;
    const { billingEntitlements: t } = e;
    let r;
    try {
        r = await he();
    } catch (n) {
        return console.error("[hasBillingEntitlements] Error getting entitlements", n), !1;
    }
    return (await Promise.all(t.map(async (n)=>{
        if (ge(n)) {
            const a = r.entitlements.find((o)=>o.priceName === n.entitlement);
            return a ? await n.condition(a) : !1;
        } else return r.entitlements.map((o)=>o.priceName).includes(n);
    }))).every((n)=>n === !0);
}, A = (e)=>e !== void 0 && typeof e == "object", Ie = async (e)=>{
    const t = [];
    return e.roles && t.push(le({
        roles: e.roles,
        forceApi: A(e.forceApi) ? e.forceApi.roles : e.forceApi
    })), e.permissions && t.push(ae({
        permissions: e.permissions,
        forceApi: A(e.forceApi) ? e.forceApi.permissions : e.forceApi
    })), e.featureFlags && t.push(de({
        featureFlags: e.featureFlags,
        forceApi: A(e.forceApi) ? e.forceApi.featureFlags : e.forceApi
    })), e.billingEntitlements && t.push(me({
        billingEntitlements: e.billingEntitlements
    })), (await Promise.all(t)).every(Boolean);
};
function ke(e, t) {
    if (!e) return null;
    const r = e.split(".");
    if (r.length !== 3) return null;
    const s = r[1].replace(/-/g, "+").replace(/_/g, "/"), n = decodeURIComponent(atob(s).split("").map((a)=>"%" + ("00" + a.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(n);
}
const m = async (e = i.accessToken)=>{
    const t = _();
    if (!t) return null;
    const r = await t.getSessionItem(e === "accessToken" ? i.accessToken : i.idToken);
    if (!r) return null;
    const s = ke(r);
    return s || console.warn("No decoded token found"), s;
}, G = async (e = "accessToken")=>m(e), L = async (e, t = "accessToken")=>{
    const r = await G(t);
    return r ? {
        name: e,
        value: r[e]
    } : null;
}, Ee = async ()=>{
    const e = await m();
    return e ? e.org_code || e["x-hasura-org-code"] : null;
}, Pe = async (e = i.accessToken)=>{
    const t = _();
    if (!t) return null;
    const r = await t.getSessionItem(e === "accessToken" ? i.accessToken : i.idToken);
    return r || null;
}, Ue = async (e, t)=>{
    if (t?.forceApi) {
        const o = (await S({
            url: "account_api/v1/feature_flags"
        })).feature_flags.find((u)=>u.name === e);
        return o ? o.value : null;
    }
    const r = await m();
    if (!r) return null;
    const s = r.feature_flags || r["x-hasura-feature-flags"];
    return s ? s[e]?.v ?? null : null;
}, be = async ()=>{
    const e = await G("idToken");
    if (!e) return null;
    const { sub: t } = e;
    return t ? {
        id: e.sub,
        givenName: e.given_name,
        familyName: e.family_name,
        email: e.email,
        picture: e.picture
    } : (console.error("No sub in idToken"), null);
}, Re = async (e, t)=>{
    if (t?.forceApi) return U(`account_api/v1/permission/${encodeURIComponent(e)}`);
    const r = await m();
    if (!r) return {
        permissionKey: e,
        orgCode: null,
        isGranted: !1
    };
    const s = r.permissions || [];
    return {
        permissionKey: e,
        orgCode: r.org_code,
        isGranted: !!s.includes(e)
    };
}, ze = async ()=>{
    const e = await m("idToken");
    return e ? !e.org_codes && !e["x-hasura-org-codes"] ? (console.warn("Org codes not found in token, ensure org codes have been included in the token customisation within the application settings"), null) : e.org_codes || e["x-hasura-org-codes"] : null;
}, Fe = async (e)=>{
    try {
        const t = await m("accessToken");
        if (!t) return !1;
        if (!t.exp) return console.error("Token does not have an expiry"), !1;
        const r = t.exp < Math.floor(Date.now() / 1e3);
        return r && e?.useRefreshToken ? (await x({
            domain: e.domain,
            clientId: e.clientId
        })).success : !r;
    } catch (t) {
        return console.error("Error checking authentication:", t), !1;
    }
}, x = async ({ domain: e, clientId: t, refreshType: r = w.refreshToken, onRefresh: s })=>{
    const n = (u)=>(s && s(u), u);
    if (!e) return n({
        success: !1,
        error: "Domain is required for token refresh"
    });
    if (!t) return n({
        success: !1,
        error: "Client ID is required for token refresh"
    });
    let a = "", o;
    if (c.useInsecureForRefreshToken || !$(e) ? o = C() : o = _(), r === w.refreshToken) {
        if (!o) return n({
            success: !1,
            error: "No active storage found"
        });
        if (a = await o.getSessionItem(i.refreshToken), !a) return n({
            success: !1,
            error: "No refresh token found"
        });
    }
    R();
    try {
        const u = await fetch(`${b(e)}/oauth2/token`, {
            method: "POST",
            ...r === w.cookie && {
                credentials: "include"
            },
            headers: {
                "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            body: new URLSearchParams({
                ...r === w.refreshToken && {
                    refresh_token: a
                },
                grant_type: "refresh_token",
                client_id: t
            }).toString()
        });
        if (!u.ok) return n({
            success: !1,
            error: "Failed to refresh token"
        });
        const l = await u.json();
        if (l.access_token) {
            const f = _();
            return f ? (q(l.expires_in, async ()=>{
                x({
                    domain: e,
                    clientId: t,
                    refreshType: r,
                    onRefresh: s
                });
            }), o && (await f.setSessionItem(i.accessToken, l.access_token), l.id_token && await f.setSessionItem(i.idToken, l.id_token), l.refresh_token && await o.setSessionItem(i.refreshToken, l.refresh_token)), n({
                success: !0,
                [i.accessToken]: l.access_token,
                [i.idToken]: l.id_token,
                [i.refreshToken]: l.refresh_token
            })) : n({
                success: !1,
                error: "No active storage found"
            });
        }
    } catch (u) {
        return n({
            success: !1,
            error: `No access token received: ${u}`
        });
    }
    return n({
        success: !1,
        error: "No access token received"
    });
}, g = {
    secure: null,
    insecure: null
}, Le = (e)=>{
    g.secure = e;
}, _ = ()=>g.secure || null, Ne = ()=>g.secure !== null, De = ()=>{
    g.secure = null;
}, Ve = (e)=>{
    g.insecure = e;
}, C = ()=>g.insecure || g.secure || null, Me = ()=>g.insecure !== null, je = ()=>{
    g.insecure = null;
}, Be = async (e)=>(console.warn("Warning: generateProfileUrl is deprecated. Please use generatePortalUrl instead."), _e({
        domain: e.domain,
        returnUrl: e.returnUrl,
        subNav: e.subNav
    }));
function we(e, t = []) {
    try {
        const r = new URL(e);
        return !t.includes(r.protocol) && !!r.host;
    } catch  {
        return !1;
    }
}
const _e = async ({ domain: e, returnUrl: t, subNav: r })=>{
    const s = _();
    if (!s) throw new Error("generatePortalUrl: Active storage not found");
    const n = await s.getSessionItem(i.accessToken);
    if (!n) throw new Error("generatePortalUrl: Access Token not found");
    if (!e || typeof e != "string") {
        const l = await L("iss");
        if (!l?.value || typeof l.value != "string") throw new Error("generatePortalUrl: Unable to determine domain from access token");
        e = l.value;
    }
    if (!we(t, [
        "ftp:",
        "ws:"
    ])) throw new Error("generatePortalUrl: returnUrl must be an absolute URL");
    const a = new URLSearchParams({
        subnav: r || B.profile,
        return_url: t
    }), o = await fetch(`${b(e)}/account_api/v1/portal_link?${a.toString()}`, {
        headers: {
            Authorization: `Bearer ${n}`
        }
    });
    if (!o.ok) throw new Error(`Failed to fetch profile URL: ${o.status} ${o.statusText}`);
    const u = await o.json();
    if (!u.url || typeof u.url != "string") throw new Error("Invalid URL received from API");
    try {
        return {
            url: new URL(u.url)
        };
    } catch (l) {
        throw console.error(l), new Error(`Invalid URL format received from API: ${u.url}`);
    }
}, qe = {
    __esModule: !0,
    default: async ()=>(await import(/* webpackIgnore: true */ "./expoSecureStore-DT0Gf-SP.js")).ExpoSecureStore
};
;
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export s as splitString>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "splitString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["s"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "A",
    ()=>we,
    "B",
    ()=>Se,
    "C",
    ()=>_e,
    "D",
    ()=>pe,
    "E",
    ()=>Ue,
    "F",
    ()=>$,
    "G",
    ()=>ye,
    "H",
    ()=>p,
    "I",
    ()=>ve,
    "J",
    ()=>$e,
    "K",
    ()=>Te,
    "L",
    ()=>T,
    "M",
    ()=>xe,
    "N",
    ()=>Ie,
    "O",
    ()=>ie,
    "P",
    ()=>le,
    "Q",
    ()=>ue,
    "R",
    ()=>H,
    "S",
    ()=>A,
    "T",
    ()=>N,
    "U",
    ()=>V,
    "V",
    ()=>B,
    "W",
    ()=>I,
    "X",
    ()=>w,
    "a",
    ()=>a,
    "b",
    ()=>c,
    "c",
    ()=>L,
    "d",
    ()=>P,
    "e",
    ()=>oe,
    "f",
    ()=>se,
    "g",
    ()=>C,
    "h",
    ()=>ae,
    "i",
    ()=>ce,
    "j",
    ()=>v,
    "k",
    ()=>F,
    "l",
    ()=>b,
    "m",
    ()=>G,
    "n",
    ()=>_,
    "o",
    ()=>Ce,
    "p",
    ()=>re,
    "q",
    ()=>X,
    "r",
    ()=>de,
    "s",
    ()=>R,
    "t",
    ()=>M,
    "u",
    ()=>fe,
    "v",
    ()=>he,
    "w",
    ()=>k,
    "x",
    ()=>ge,
    "y",
    ()=>me,
    "z",
    ()=>ke
]);
var H = /* @__PURE__ */ ((e)=>(e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(H || {}), N = /* @__PURE__ */ ((e)=>(e.none = "none", e.create = "create", e.login = "login", e))(N || {}), V = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(V || {}), B = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(B || {}), I = /* @__PURE__ */ ((e)=>(e.logout = "logout", e.login = "login", e.register = "registration", e.token = "token", e.profile = "profile", e))(I || {}), w = /* @__PURE__ */ ((e)=>(e[e.refreshToken = 0] = "refreshToken", e[e.cookie = 1] = "cookie", e))(w || {});
const L = (e)=>{
    const t = (i)=>btoa(i).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    if (e instanceof ArrayBuffer) {
        const i = new Uint8Array(e), s = String.fromCharCode(...i);
        return t(s);
    }
    const n = new TextEncoder().encode(e), o = String.fromCharCode(...n);
    return t(o);
}, C = (e = 28)=>{
    if (crypto) {
        const t = new Uint8Array(e / 2);
        return crypto.getRandomValues(t), Array.from(t, J).join("");
    } else return W(e);
};
function J(e) {
    return e.toString(16).padStart(2, "0");
}
function W(e = 28) {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let r = "";
    const n = t.length;
    for(let o = 0; o < e; o++)r += t.charAt(Math.floor(Math.random() * n));
    return r;
}
const oe = (e)=>{
    e = e.split("?")[1];
    const t = new URLSearchParams(e);
    return {
        accessToken: t.get("access_token"),
        idToken: t.get("id_token"),
        expiresIn: +(t.get("expires_in") || 0)
    };
}, P = (e)=>e.replace(/\/$/, ""), G = (e, t = !1)=>{
    const r = Array.isArray(e.audience) ? e.audience.join(" ") : e.audience || "", n = {
        login_hint: e.loginHint,
        is_create_org: e.isCreateOrg?.toString(),
        connection_id: e.connectionId,
        redirect_uri: e.redirectURL ? t ? e.redirectURL : P(e.redirectURL) : void 0,
        audience: r,
        scope: e.scope?.join(" ") || "email profile openid offline",
        prompt: e.prompt,
        lang: e.lang,
        org_code: e.orgCode,
        org_name: e.orgName,
        has_success_page: e.hasSuccessPage?.toString(),
        workflow_deployment_id: e.workflowDeploymentId,
        supports_reauth: e.supportsReauth?.toString(),
        plan_interest: e.planInterest,
        pricing_table_key: e.pricingTableKey,
        pages_mode: e.pagesMode
    };
    return Object.keys(n).forEach((o)=>n[o] === void 0 && delete n[o]), n;
}, U = (e)=>typeof e != "object" || e === null ? e : Array.isArray(e) ? e.map((t)=>U(t)) : Object.fromEntries(Object.entries(e).map(([t, r])=>[
            t.replace(/_([a-z])/g, (n, o)=>o.toUpperCase()),
            U(r)
        ])), Z = [
    // UTM tags
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_content",
    "utm_term",
    // Google Ads smart campaign tracking
    "gclid",
    "click_id",
    "hsa_acc",
    "hsa_cam",
    "hsa_grp",
    "hsa_ad",
    "hsa_src",
    "hsa_tgt",
    "hsa_kw",
    "hsa_mt",
    "hsa_net",
    "hsa_ver",
    // Marketing category
    "match_type",
    "keyword",
    "device",
    "ad_group_id",
    "campaign_id",
    "creative",
    "network",
    "ad_position",
    "fbclid",
    "li_fat_id",
    "msclkid",
    "twclid",
    "ttclid"
], se = async (e, t = I.login, r, n)=>{
    const o = `${e}/oauth2/auth`, i = T();
    if (r.reauthState) try {
        const u = U(JSON.parse(atob(r.reauthState)));
        r = {
            ...r,
            ...u
        }, delete r.reauthState;
    } catch (u) {
        const h = u instanceof Error ? u.message : "Unknown error";
        throw new Error(`Error handing reauth state: ${h}`);
    }
    if (!r.clientId) throw new Error("Error generating auth URL: Client ID missing");
    const s = {
        client_id: r.clientId,
        response_type: r.responseType || "code",
        ...G(r, n?.disableUrlSanitization)
    };
    r.state || (r.state = C(32)), i && i.setSessionItem(a.state, r.state), s.state = r.state, r.nonce || (r.nonce = C(16)), s.nonce = r.nonce, i && i.setSessionItem(a.nonce, r.nonce);
    let d = "";
    if (r.codeChallenge) s.code_challenge = r.codeChallenge;
    else {
        const { codeVerifier: u, codeChallenge: h } = await Q();
        d = u, i && i.setSessionItem(a.codeVerifier, u), s.code_challenge = h;
    }
    s.code_challenge_method = "S256", r.codeChallengeMethod && (s.code_challenge_method = r.codeChallengeMethod), !r.prompt && t === I.register && (s.prompt = N.create), r.properties && Object.keys(r.properties).forEach((u)=>{
        if (!Z.includes(u)) {
            console.warn("Unsupported Property for url generation: ", u);
            return;
        }
        const h = r.properties?.[u];
        h !== void 0 && (s[u] = h);
    });
    const l = new URLSearchParams(s).toString();
    return {
        url: new URL(`${o}?${l}`),
        state: s.state,
        nonce: s.nonce,
        codeChallenge: s.code_challenge,
        codeVerifier: d
    };
};
async function Q() {
    const e = C(52), t = new TextEncoder().encode(e);
    let r = "";
    if (!crypto) r = L(btoa(e));
    else {
        const n = await crypto.subtle.digest("SHA-256", t);
        r = L(n);
    }
    return {
        codeVerifier: e,
        codeChallenge: r
    };
}
let y;
function F(e, t) {
    if (b(), "undefined" > "u") throw new Error("setRefreshTimer requires a browser environment");
    if (e <= 0) throw new Error("Timer duration must be positive");
    y = window.setTimeout(t, Math.min(e * 1e3 - 1e4, 864e5));
}
function b() {
    y !== void 0 && (window.clearTimeout(y), y = void 0);
}
const _ = {
    framework: "",
    frameworkVersion: "",
    sdkVersion: ""
}, D = async ()=>{
    await T()?.removeItems(a.state, a.nonce, a.codeVerifier);
}, X = ()=>`${_.framework}/${_.sdkVersion}/${_.frameworkVersion}/Javascript`, ae = async ({ urlParams: e, domain: t, clientId: r, redirectURL: n, autoRefresh: o = !1, onRefresh: i })=>{
    const s = e.get("state"), d = e.get("code");
    if (!s || !d) return console.error("Invalid state or code"), {
        success: !1,
        error: "Invalid state or code"
    };
    const l = T();
    if (!l) return console.error("No active storage found"), {
        success: !1,
        error: "Authentication storage is not initialized"
    };
    (!_.framework || !_.frameworkVersion) && console.warn("Framework and version not set. Please set the framework and version in the config object");
    const u = await l.getSessionItem(a.state);
    if (s !== u) return console.error("Invalid state"), {
        success: !1,
        error: `Invalid state; supplied ${s}, expected ${u}`
    };
    const h = await l.getSessionItem(a.codeVerifier);
    if (h === null) return console.error("Code verifier not found"), {
        success: !1,
        error: "Code verifier not found"
    };
    const E = {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
    };
    _.framework && (E["Kinde-SDK"] = X());
    const j = {
        method: "POST",
        ...!c.useInsecureForRefreshToken && v(t) ? {
            credentials: "include"
        } : {},
        headers: new Headers(E),
        body: new URLSearchParams({
            client_id: r,
            code: d,
            code_verifier: h,
            grant_type: "authorization_code",
            redirect_uri: n
        })
    };
    let S;
    b();
    try {
        if (S = await fetch(`${t}/oauth2/token`, j), !S?.ok) {
            const m = await S.text();
            return console.error("Token exchange failed:", S.status, m), {
                success: !1,
                error: `Token exchange failed: ${S.status} - ${m}`
            };
        }
    } catch (m) {
        return D(), console.error("Token exchange failed:", m), {
            success: !1,
            error: `Token exchange failed: ${m}`
        };
    }
    const f = await S.json(), z = p();
    z && z.setItems({
        [a.accessToken]: f.access_token,
        [a.idToken]: f.id_token,
        [a.refreshToken]: f.refresh_token
    }), (c.useInsecureForRefreshToken || !v(t)) && l.setSessionItem(a.refreshToken, f.refresh_token), o && F(f.expires_in, async ()=>{
        $({
            domain: t,
            clientId: r,
            onRefresh: i
        });
    }), D();
    const q = ((m)=>(m.search = "", m))(new URL(window.location.toString()));
    return window.history.replaceState(window.history.state, "", q), !f.access_token || !f.id_token || !f.refresh_token ? {
        success: !1,
        error: "No access token received"
    } : {
        success: !0,
        [a.accessToken]: f.access_token,
        [a.idToken]: f.id_token,
        [a.refreshToken]: f.refresh_token
    };
};
function Y(e) {
    const r = document.cookie.split("; ").find((n)=>n.startsWith(`${e}=`));
    if (!r) return null;
    try {
        const n = r.split("=")[1];
        return n ? decodeURIComponent(n) : null;
    } catch (n) {
        return console.error(`Error parsing cookie ${e}:`, n), null;
    }
}
const O = "_kbrte", ce = async ({ domain: e, clientId: t })=>{
    if (!e) return {
        success: !1,
        error: "Domain is required for authentication check"
    };
    if (!t) return {
        success: !1,
        error: "Client ID is required for authentication check"
    };
    const r = v(e), n = c.useInsecureForRefreshToken;
    let o = null;
    return r && !n && (o = Y(O)), await $({
        domain: e,
        clientId: t,
        refreshType: o ? w.cookie : w.refreshToken
    });
}, v = (e)=>!e.match(/^(?:https?:\/\/)?[a-zA-Z0-9][.-a-zA-Z0-9]*\.kinde\.com$/i);
function R(e, t) {
    return t <= 0 ? [] : e.match(new RegExp(`.{1,${t}}`, "g")) || [];
}
var a = /* @__PURE__ */ ((e)=>(e.accessToken = "accessToken", e.idToken = "idToken", e.refreshToken = "refreshToken", e.state = "state", e.nonce = "nonce", e.codeVerifier = "codeVerifier", e))(a || {});
class A {
    async setItems(t) {
        await Promise.all(Object.entries(t).map(([r, n])=>this.setSessionItem(r, n)));
    }
    async removeItems(...t) {
        await Promise.all(t.map((r)=>this.removeSessionItem(r)));
    }
}
class ie extends A {
    memCache = {};
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.memCache = {};
    }
    /**
   * Sets the provided key-value store to the memory cache.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), typeof r == "string") {
            R(r, c.maxLength).forEach((n, o)=>{
                this.memCache[`${c.keyPrefix}${t}${o}`] = n;
            });
            return;
        }
        this.memCache[`${c.keyPrefix}${String(t)}0`] = r;
    }
    /**
   * Gets the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        if (this.memCache[`${c.keyPrefix}${String(t)}0`] === void 0) return null;
        let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
        for(; this.memCache[o] !== void 0;)r += this.memCache[o], n++, o = `${c.keyPrefix}${String(t)}${n}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        for(const r in this.memCache)r.startsWith(`${c.keyPrefix}${String(t)}`) && delete this.memCache[r];
    }
}
function x(e) {
    return new Promise((t, r)=>{
        chrome.storage.local.get([
            e
        ], function(n) {
            chrome.runtime.lastError ? r(void 0) : t(n[e]);
        });
    });
}
class le extends A {
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        await chrome.storage.local.clear();
    }
    /**
   * Sets the provided key-value store to the chrome.store.local.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), typeof r == "string") {
            R(r, c.maxLength).forEach(async (n, o)=>{
                await chrome.storage.local.set({
                    [`${c.keyPrefix}${t}${o}`]: n
                });
            });
            return;
        }
        await chrome.storage.local.set({
            [`${c.keyPrefix}${t}0`]: r
        });
    }
    /**
   * Gets the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
        for(; await x(`${c.keyPrefix}${String(t)}${n}`) !== void 0;)r += await x(o), n++, o = `${c.keyPrefix}${String(t)}${n}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        let r = 0;
        for(; await x(`${c.keyPrefix}${String(t)}${r}`) !== void 0;)await chrome.storage.local.remove(`${c.keyPrefix}${String(t)}${r}`), r++;
    }
}
class ue extends A {
    constructor(){
        super(), c.useInsecureForRefreshToken && console.warn("LocalStorage store should not be used in production");
    }
    internalItems = /* @__PURE__ */ new Set();
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.internalItems.forEach((t)=>{
            this.removeSessionItem(t);
        });
    }
    /**
   * Sets the provided key-value store to the localStorage cache.
   * @param {V} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(t, r) {
        if (await this.removeSessionItem(t), this.internalItems.add(t), typeof r == "string") {
            R(r, c.maxLength).forEach((n, o)=>{
                localStorage.setItem(`${c.keyPrefix}${t}${o}`, n);
            });
            return;
        }
        localStorage.setItem(`${c.keyPrefix}${t}0`, r);
    }
    /**
   * Gets the item for the provided key from the localStorage cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(t) {
        if (localStorage.getItem(`${c.keyPrefix}${t}0`) === null) return null;
        let r = "", n = 0, o = `${c.keyPrefix}${String(t)}${n}`;
        for(; localStorage.getItem(o) !== null;)r += localStorage.getItem(o), n++, o = `${c.keyPrefix}${String(t)}${n}`;
        return r;
    }
    /**
   * Removes the item for the provided key from the localStorage cache.
   * @param {V} itemKey
   * @returns {void}
   */ async removeSessionItem(t) {
        let r = 0;
        for(; localStorage.getItem(`${c.keyPrefix}${String(t)}${r}`) !== null;)localStorage.removeItem(`${c.keyPrefix}${String(t)}${r}`), r++;
        this.internalItems.delete(t);
    }
}
const c = {
    /**
   * The prefix to use for the storage keys.
   */ keyPrefix: "kinde-",
    /**
   * The maximum length of the storage.
   *
   * If the length is exceeded the items will be split into multiple storage items.
   */ maxLength: 2e3,
    /**
   * Use insecure storage for refresh token.
   *
   * Warning: This should only be used when you're not using a custom domain and no backend app to authenticate on.
   */ useInsecureForRefreshToken: !1
};
function K(e, t) {
    if (!e) return null;
    const r = e.split(".");
    if (r.length !== 3) return null;
    const n = r[1].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(atob(n).split("").map((i)=>"%" + ("00" + i.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(o);
}
const k = async (e = a.accessToken)=>{
    const t = p();
    if (!t) return null;
    const r = await t.getSessionItem(e === "accessToken" ? a.accessToken : a.idToken);
    if (!r) return null;
    const n = K(r);
    return n || console.warn("No decoded token found"), n;
}, M = async (e = "accessToken")=>k(e), de = async (e, t = "accessToken")=>{
    const r = await M(t);
    return r ? {
        name: e,
        value: r[e]
    } : null;
}, fe = async ()=>{
    const e = await k();
    return e ? e.org_code || e["x-hasura-org-code"] : null;
}, he = async (e = a.accessToken)=>{
    const t = p();
    if (!t) return null;
    const r = await t.getSessionItem(e === "accessToken" ? a.accessToken : a.idToken);
    return r || null;
}, ge = async (e)=>{
    const t = await k();
    if (!t) return null;
    const r = t.feature_flags || t["x-hasura-feature-flags"];
    return r ? r[e]?.v ?? null : null;
}, me = async ()=>{
    const e = await M("idToken");
    if (!e) return null;
    const { sub: t } = e;
    return t ? {
        id: e.sub,
        givenName: e.given_name,
        familyName: e.family_name,
        email: e.email,
        picture: e.picture
    } : (console.error("No sub in idToken"), null);
}, ke = async (e)=>{
    const t = await k();
    if (!t) return {
        permissionKey: e,
        orgCode: null,
        isGranted: !1
    };
    const r = t.permissions || [];
    return {
        permissionKey: e,
        orgCode: t.org_code,
        isGranted: !!r.includes(e)
    };
}, we = async ()=>{
    const e = await k();
    if (!e) return {
        orgCode: null,
        permissions: []
    };
    const t = e.permissions || e["x-hasura-permissions"] || [];
    return {
        orgCode: e.org_code || e["x-hasura-org-code"],
        permissions: t
    };
}, Se = async ()=>{
    const e = await k("idToken");
    return e ? !e.org_codes && !e["x-hasura-org-codes"] ? (console.warn("Org codes not found in token, ensure org codes have been included in the token customisation within the application settings"), null) : e.org_codes || e["x-hasura-org-codes"] : null;
}, _e = async ()=>{
    const e = await k();
    return e ? !e.roles && !e["x-hasura-roles"] ? (console.warn("No roles found in token, ensure roles have been included in the token customisation within the application settings"), []) : e.roles || e["x-hasura-roles"] : [];
}, pe = async (e)=>{
    try {
        const t = await k("accessToken");
        if (!t) return !1;
        if (!t.exp) return console.error("Token does not have an expiry"), !1;
        const r = t.exp < Math.floor(Date.now() / 1e3);
        return r && e?.useRefreshToken ? (await $({
            domain: e.domain,
            clientId: e.clientId
        })).success : !r;
    } catch (t) {
        return console.error("Error checking authentication:", t), !1;
    }
}, $ = async ({ domain: e, clientId: t, refreshType: r = w.refreshToken, onRefresh: n })=>{
    const o = (d)=>(n && n(d), d);
    if (!e) return o({
        success: !1,
        error: "Domain is required for token refresh"
    });
    if (!t) return o({
        success: !1,
        error: "Client ID is required for token refresh"
    });
    let i = "", s;
    if (c.useInsecureForRefreshToken || !v(e) ? s = T() : s = p(), r === w.refreshToken) {
        if (!s) return o({
            success: !1,
            error: "No active storage found"
        });
        if (i = await s.getSessionItem(a.refreshToken), !i) return o({
            success: !1,
            error: "No refresh token found"
        });
    }
    b();
    try {
        const d = await fetch(`${P(e)}/oauth2/token`, {
            method: "POST",
            ...r === w.cookie && {
                credentials: "include"
            },
            headers: {
                "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            body: new URLSearchParams({
                ...r === w.refreshToken && {
                    refresh_token: i
                },
                grant_type: "refresh_token",
                client_id: t
            }).toString()
        });
        if (!d.ok) return o({
            success: !1,
            error: "Failed to refresh token"
        });
        const l = await d.json();
        if (l.access_token) {
            const u = p();
            return u ? (F(l.expires_in, async ()=>{
                $({
                    domain: e,
                    clientId: t,
                    refreshType: r,
                    onRefresh: n
                });
            }), s && (await u.setSessionItem(a.accessToken, l.access_token), l.id_token && await u.setSessionItem(a.idToken, l.id_token), l.refresh_token && await s.setSessionItem(a.refreshToken, l.refresh_token)), o({
                success: !0,
                [a.accessToken]: l.access_token,
                [a.idToken]: l.id_token,
                [a.refreshToken]: l.refresh_token
            })) : o({
                success: !1,
                error: "No active storage found"
            });
        }
    } catch (d) {
        return o({
            success: !1,
            error: `No access token received: ${d}`
        });
    }
    return o({
        success: !1,
        error: "No access token received"
    });
}, g = {
    secure: null,
    insecure: null
}, ye = (e)=>{
    g.secure = e;
}, p = ()=>g.secure || null, ve = ()=>g.secure !== null, $e = ()=>{
    g.secure = null;
}, Te = (e)=>{
    g.insecure = e;
}, T = ()=>g.insecure || g.secure || null, xe = ()=>g.insecure !== null, Ie = ()=>{
    g.insecure = null;
}, Ce = async (e)=>(console.warn("Warning: generateProfileUrl is deprecated. Please use generatePortalUrl instead."), re({
        domain: e.domain,
        returnUrl: e.returnUrl,
        subNav: e.subNav
    }));
function ee(e, t = []) {
    try {
        const r = new URL(e);
        return !t.includes(r.protocol) && !!r.host;
    } catch  {
        return !1;
    }
}
const re = async ({ domain: e, returnUrl: t, subNav: r })=>{
    const n = p();
    if (!n) throw new Error("generatePortalUrl: Active storage not found");
    const o = await n.getSessionItem(a.accessToken);
    if (!o) throw new Error("generatePortalUrl: Access Token not found");
    if (!ee(t, [
        "ftp:",
        "ws:"
    ])) throw new Error("generatePortalUrl: returnUrl must be an absolute URL");
    const i = new URLSearchParams({
        sub_nav: r || V.profile,
        return_url: t
    }), s = await fetch(`${P(e)}/account_api/v1/portal_link?${i.toString()}`, {
        headers: {
            Authorization: `Bearer ${o}`
        }
    });
    if (!s.ok) throw new Error(`Failed to fetch profile URL: ${s.status} ${s.statusText}`);
    const d = await s.json();
    if (!d.url || typeof d.url != "string") throw new Error("Invalid URL received from API");
    try {
        return {
            url: new URL(d.url)
        };
    } catch (l) {
        throw console.error(l), new Error(`Invalid URL format received from API: ${d.url}`);
    }
}, Ue = {
    __esModule: !0,
    default: async ()=>(await import(/* webpackIgnore: true */ "./expoSecureStore-C1h3JFYV.js")).ExpoSecureStore
};
;
}),
"[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript) <export p as generatePortalUrl>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generatePortalUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["p"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript) <export O as MemoryStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MemoryStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["O"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript) <export G as setActiveStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setActiveStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["G"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript) <export a as StorageKeys>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StorageKeys",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["a"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2d$oss$2f$kinde$2d$typescript$2d$sdk$2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$DxtIxOEZ$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde-oss/kinde-typescript-sdk/node_modules/@kinde/js-utils/dist/main-DxtIxOEZ.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export V as MemoryStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MemoryStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["V"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export H as setActiveStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setActiveStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["H"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export a as StorageKeys>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StorageKeys",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["a"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export _ as PortalPage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PortalPage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["_"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript) <export p as generatePortalUrl>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generatePortalUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["p"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d$D22foZsM$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main-D22foZsM.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/destr/dist/index.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>destr,
    "destr",
    ()=>destr,
    "safeDestr",
    ()=>safeDestr
]);
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
    if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
        warnKeyDropped(key);
        return;
    }
    return value;
}
function warnKeyDropped(key) {
    console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
    if (typeof value !== "string") {
        return value;
    }
    if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
        return value.slice(1, -1);
    }
    const _value = value.trim();
    if (_value.length <= 9) {
        switch(_value.toLowerCase()){
            case "true":
                {
                    return true;
                }
            case "false":
                {
                    return false;
                }
            case "undefined":
                {
                    return void 0;
                }
            case "null":
                {
                    return null;
                }
            case "nan":
                {
                    return Number.NaN;
                }
            case "infinity":
                {
                    return Number.POSITIVE_INFINITY;
                }
            case "-infinity":
                {
                    return Number.NEGATIVE_INFINITY;
                }
        }
    }
    if (!JsonSigRx.test(value)) {
        if (options.strict) {
            throw new SyntaxError("[destr] Invalid JSON");
        }
        return value;
    }
    try {
        if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
            if (options.strict) {
                throw new Error("[destr] Possible prototype pollution");
            }
            return JSON.parse(value, jsonParseTransform);
        }
        return JSON.parse(value);
    } catch (error) {
        if (options.strict) {
            throw error;
        }
        return value;
    }
}
function safeDestr(value, options = {}) {
    return destr(value, {
        ...options,
        strict: true
    });
}
;
}),
"[project]/node_modules/cookie/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */ const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */ const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */ const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */ const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (()=>{
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */ function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2) return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    }while (index < len)
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index;
    }while (++index < max)
    return max;
}
function endIndex(str, index, min) {
    while(index > min){
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */ function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options) return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
        switch(priority){
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch(sameSite){
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */ function decode(str) {
    if (str.indexOf("%") === -1) return str;
    try {
        return decodeURIComponent(str);
    } catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */ function isDate(val) {
    return __toString.call(val) === "[object Date]";
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@kinde/jwt-validator/dist/jwt-validator.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "validateToken",
    ()=>v
]);
const d = /* @__PURE__ */ new Map();
function b() {
    return "undefined" < "u" ? window.crypto : globalThis.crypto;
}
async function A(e) {
    let t = 0;
    for(; t < 3;){
        const n = new AbortController(), a = setTimeout(()=>n.abort(), 5e3);
        try {
            const o = await fetch(`${e}/.well-known/jwks.json`, {
                signal: n.signal
            });
            if (clearTimeout(a), !o.ok) throw new Error(`Failed to fetch JWKS: ${o.status} ${o.statusText}`);
            return await o.json();
        } catch (o) {
            t++, console.error(`Attempt ${t} - Error fetching JWKS:`, o);
        }
    }
    throw new Error("Failed to fetch JWKS after multiple retries");
}
async function S(e, r, t) {
    t && d.delete(r);
    let n = d.get(r);
    n || (n = await A(r), d.set(r, n));
    try {
        return await E(e, JSON.stringify(n)), {
            valid: !0,
            message: "Token is valid"
        };
    } catch (a) {
        return t ? {
            valid: !1,
            message: a instanceof Error ? a.message : "Unknown Error"
        } : S(e, r, !0);
    }
}
async function E(e, r) {
    const [t, n, a] = e.split("."), k = JSON.parse(atob(t)).kid, i = J(r, k);
    if (!i || i.kty !== "RSA" || !i.n || !i.e || i.use !== "sig") throw new Error("Invalid JWK RSA key");
    const c = b();
    if (c != null && c.subtle) {
        const l = m(i.n), u = m(i.e), f = {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
        try {
            const s = {
                kty: "RSA",
                n: p(l),
                e: p(u),
                alg: "RS256"
            }, w = await c.subtle.importKey("jwk", s, f, !0, [
                "verify"
            ]), h = t + "." + n, g = j(a), y = await c.subtle.verify(f, w, g, new TextEncoder().encode(h));
            if (!y) throw new Error("Signature verification failed");
            return y;
        } catch (s) {
            throw s;
        }
    } else {
        const { KJUR: l, KEYUTIL: u, b64utoutf8: f } = await __turbopack_context__.A("[project]/node_modules/@kinde/jwt-validator/dist/jsrsasign-B2gZIJhY.js [app-rsc] (ecmascript, async loader)").then((g)=>g.j), s = JSON.parse(f(t));
        if (s.alg !== "RS256") throw new Error("Unsupported signature algorithm: " + s);
        const w = u.getKey(i);
        if (!l.jws.JWS.verifyJWT(e, w, {
            alg: [
                "RS256"
            ]
        })) throw new Error("Signature verification failed");
        return !0;
    }
}
function p(e) {
    let r = e.toString(16);
    r.length % 2 !== 0 && (r = "0" + r);
    const t = new Uint8Array(r.match(/.{1,2}/g).map((a)=>parseInt(a, 16)));
    return btoa(String.fromCharCode.apply(null, Array.from(t))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function J(e, r) {
    const t = JSON.parse(e);
    for (const n of t.keys)if (n.kid === r) return n;
    throw new Error(`JWK not found${r ? ` for kid ${r}` : ""}`);
}
function m(e) {
    e = e.replace(/[^A-Za-z0-9\-_]/g, ""), e += Array.from({
        length: (4 - e.length % 4) % 4
    }, ()=>"=").join("");
    const r = e.replace(/-/g, "+").replace(/_/g, "/");
    let t;
    try {
        t = atob(r);
    } catch (o) {
        throw new Error("Invalid Base64 string: " + o.message);
    }
    const n = Array.from(t, (o)=>o.charCodeAt(0).toString(16).padStart(2, "0")).join("");
    if (n.toLowerCase() === "ffffffffffffffff" || n.toLowerCase() === "7ff0000000000000") throw new Error("Decoded value represents NaN or Infinity");
    const a = n.replace(/^0+/, "");
    return BigInt("0x" + a || "0");
}
function j(e) {
    return Uint8Array.from(atob(e.replace(/-/g, "+").replace(/_/g, "/")), (r)=>r.charCodeAt(0));
}
const v = async (e)=>e.token ? e.domain ? e.token.split(".").length !== 3 ? {
        valid: !1,
        message: "Invalid JWT format"
    } : await S(e.token, e.domain) : {
        valid: !1,
        message: "Domain is required"
    } : {
        valid: !1,
        message: "Token is required"
    };
;
}),
"[project]/node_modules/uncrypto/dist/crypto.node.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_crypto,
    "getRandomValues",
    ()=>getRandomValues,
    "randomUUID",
    ()=>randomUUID,
    "subtle",
    ()=>subtle
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const subtle = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto?.subtle || {};
const randomUUID = ()=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].randomUUID();
};
const getRandomValues = (array)=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto.getRandomValues(array);
};
const _crypto = {
    randomUUID,
    getRandomValues,
    subtle
};
;
}),
];

//# sourceMappingURL=node_modules_c642a8f2._.js.map